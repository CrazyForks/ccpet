# Story 1.4: The Passage of Time

## Status
âœ… Completed

## Story

**As a** pet,  
**I want** my energy to decrease when I haven't been fed for a long time,  
**so that** I can remind my owner (the developer) to pay attention to my status.

## Acceptance Criteria

1. System has a timer (e.g., triggers every hour)
2. If no recent coding activity occurred when timer triggers, call energy module's "decrease" function
3. Status bar energy bar updates accordingly to reflect energy decrease

## Tasks / Subtasks

- [x] Configure time-based decay intervals and rates (AC: 1)
  - [x] Add DECAY_CHECK_INTERVAL and DECAY_RATE constants to src/core/config.ts
  - [x] Define energy decay calculation logic based on time elapsed since last activity
  - [x] Set appropriate default values (e.g., 1-hour interval, -5 energy per hour)
- [x] Implement timer-based decay logic in Pet class (AC: 1, 2)
  - [x] Enhance Pet.applyTimeDecay() method to use configurable intervals and rates
  - [x] Add method to check if decay should be applied based on time elapsed
  - [x] Ensure decay logic integrates with existing decreaseEnergy() method from Story 1.2
  - [x] Add proper logging for decay events using existing logger pattern
- [x] Integrate decay mechanism with CLI execution workflow (AC: 1, 3)
  - [x] Call Pet.applyTimeDecay() during each CLI execution in ClaudeCodeStatusLine
  - [x] Ensure energy bar updates reflect time-based decay in StatusBarFormatter
  - [x] Verify decay is applied before any feeding logic during CLI execution
  - [x] Test that UI immediately shows energy decrease when decay occurs
- [x] Add comprehensive unit tests for time decay functionality (All ACs)
  - [x] Test time calculation logic and decay interval checking
  - [x] Test energy decrease calculations with various time periods
  - [x] Test integration with existing energy management methods
  - [x] Test CLI workflow with time passage scenarios
  - [x] Mock Date/time for consistent testing across different execution times

## Dev Notes

### Previous Story Insights
Story 1.1 established the foundational CLI architecture with Pet class, StatusBarFormatter, and PetStorage persistence. Story 1.2 enhanced the Pet class with dedicated energy management methods (addEnergy, decreaseEnergy, getCurrentEnergy) and state thresholds. Story 1.3 implemented JSONL token processing and feeding mechanism, and **already established time decay foundation with `lastDecayTime` tracking for continuous energy decay** [Source: Story 1.3 completion notes]. The existing Pet.applyTimeDecay() method and decreaseEnergy() method provide the foundation for enhanced time-based decay functionality.

### Project Structure
Based on architecture, enhance existing files in these exact locations:
- `src/core/config.ts` - Add time decay configuration constants [Source: architecture/source-tree.md#business-logic-layer]
- `src/core/Pet.ts` - Enhance existing applyTimeDecay() method with configurable intervals [Source: architecture/source-tree.md#business-logic-layer]  
- `src/extension.ts` - Continue calling Pet.applyTimeDecay() in CLI execution flow (already implemented in Story 1.3) [Source: architecture/source-tree.md#cli-entry-point]
- `src/services/PetStorage.ts` - Continue using existing lastDecayTime persistence (already implemented in Story 1.3) [Source: architecture/source-tree.md#service-layer]

### Component Implementation Standards
Follow existing CLI architecture established in Stories 1.1-1.3 [Source: architecture/component-standards.md]:

**Enhanced Time Decay Configuration (`src/core/config.ts`):**
- Must add DECAY_CHECK_INTERVAL (time between decay checks in milliseconds)
- Must add DECAY_RATE (energy points to decrease per interval)
- Must add MINIMUM_DECAY_INTERVAL (minimum time before first decay can occur)
- Must follow existing configuration pattern with proper TypeScript types
- Must ensure constants are exported for use by Pet class

**Enhanced Pet.applyTimeDecay() Method:**
- Must check if enough time has elapsed since lastDecayTime for decay to occur
- Must use configurable DECAY_CHECK_INTERVAL instead of hardcoded 1-hour intervals
- Must call existing decreaseEnergy() method to maintain energy bounds validation
- Must update lastDecayTime after applying decay to prevent multiple rapid decays
- Must maintain observer pattern notifications through existing _notify() method
- Must follow error handling patterns with try-catch blocks and graceful degradation

**CLI Integration Pattern:**
- Must continue calling Pet.applyTimeDecay() during ClaudeCodeStatusLine execution (already established in Story 1.3)
- Must apply decay **before** any token processing/feeding logic
- Must ensure StatusBarFormatter immediately reflects energy changes from decay
- Must maintain existing state loading, decay application, and saving workflow

### State Management Pattern
Continue using existing CLI state management from Stories 1.1-1.3 [Source: architecture/state-management.md]:
- Pet.ts remains the state Subject with enhanced time decay management
- Time decay triggers Pet.decreaseEnergy() which notifies observers via existing pattern
- StatusBarFormatter continues to format pet state for CLI output including decay effects
- State persistence through PetStorage continues unchanged with lastDecayTime tracking
- All energy changes must maintain 0-100 bounds validation through existing methods

### Time Decay Configuration
Configurable time decay system [Source: Current Implementation and PRD]:
- **DECAY_CHECK_INTERVAL**: 3600000 (1 hour in milliseconds) for decay frequency
- **DECAY_RATE**: 5 (energy points to decrease per decay interval)
- **MINIMUM_DECAY_INTERVAL**: 3600000 (minimum time before first decay can occur)
- **Energy Bounds**: Automatic flooring at 0 energy through existing Pet.decreaseEnergy() method
- **Timer Implementation**: Based on CLI execution frequency, not background timers (per CLI architecture)

### Error Handling Requirements
All time decay logic must implement error handling patterns [Source: architecture/error-handling.md]:
- Wrap time calculations and decay logic in try-catch blocks
- Log decay events using console.log() for debugging and user awareness
- Implement graceful fallback if time decay calculation fails (skip decay for current execution)
- Never crash CLI execution due to time decay failures
- Handle edge cases like clock changes, negative time differences gracefully

### Tech Stack Requirements
Continue using exact versions from previous stories [Source: architecture/tech-stack.md]:
- TypeScript ~5.x.x for type safety and time calculation logic
- Node.js built-in modules (Date, Math) for time calculations and decay logic
- esbuild ~0.2x.x for fast compilation  
- Vitest ~1.x.x for testing framework
- No external dependencies for time decay logic - use native JavaScript/TypeScript capabilities

### Integration Points
Time decay integrates seamlessly with existing Story 1.1-1.3 components:
- Existing Pet.decreaseEnergy() method (implemented in Story 1.2) handles all energy reduction logic
- Existing observer pattern triggers StatusBarFormatter updates automatically  
- Existing PetStorage persists pet state with lastDecayTime (implemented in Story 1.3)
- Enhanced CLI execution flow continues calling Pet.applyTimeDecay() before feeding logic
- Existing error handling and graceful degradation patterns maintained
- **ENHANCED**: Configurable decay intervals and rates for flexible time-based gameplay

### Testing

#### Test Coverage Requirements
- All new time decay configuration in `src/core/config.ts` must have >80% test coverage
- Enhanced time decay logic in `src/core/Pet.ts` must have comprehensive tests
- Use existing Vitest framework with "Arrange-Act-Assert" pattern from previous stories

#### Test File Structure
- Configuration tests: `src/core/__tests__/config.test.ts` (enhance existing file)
- Enhanced Pet logic tests: `src/core/__tests__/Pet.test.ts` (extend existing tests)
- CLI integration tests: `src/__tests__/ccpet.test.ts` (extend existing time decay tests)
- Integration tests: `src/__tests__/integration/PetIntegration.test.ts` (extend existing file)

#### Test Requirements for Time Decay Enhancement
- Test configurable decay interval calculations (various time periods)
- Test energy decrease with different DECAY_RATE values
- Test minimum decay interval enforcement (no decay before minimum time)
- Test CLI integration with time passage scenarios using mocked dates
- Test edge cases: clock changes, very long time periods, zero time differences
- Test integration with existing Pet.decreaseEnergy() method and bounds checking
- Mock Date.now() and time-related operations for consistent testing
- Test error handling for invalid time calculations and decay failures

#### Mock Requirements
Continue using existing mock patterns from previous stories:
- Mock Date.now() and Date constructor using vi.mock() for time testing
- Mock Pet.decreaseEnergy() calls to verify correct time decay integration
- Use vi.fn() for mocking time calculations and interval checking operations
- Test state immutability and persistence with time-based scenarios
- Mock CLI execution timing for decay interval testing

### Test Commands
Use existing test commands from previous stories:
- `npm test` - Run all tests
- `npm run test:unit` - Run unit tests only
- `npm run test:coverage` - Run tests with coverage report

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-08-22 | 1.0 | Initial story creation with full context | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used
claude-sonnet-4-20250514

### Debug Log References  
*[To be filled by Dev Agent]*

### Completion Notes List
- **FINAL IMPLEMENTATION**: Enhanced Pet.ts applyTimeDecay() method with minute-level configurable decay system
- Added TIME_DECAY configuration with DECAY_CHECK_INTERVAL (1 minute), DECAY_RATE (0.0231 energy/minute), and MINIMUM_DECAY_INTERVAL (1 minute)
- Implemented minute-level continuous decay: maintains ~3-day 100â†’0 decay rate (100 Ã· 4320 minutes = 0.0231 per minute)
- **ENHANCED GRANULARITY**: Minute-based configurable parameters provide finer control while preserving original ~3-day timeline
- Enhanced existing CLI integration continues calling applyTimeDecay() before feeding logic with improved logging
- Added comprehensive unit tests covering minute-level configurable decay, energy bounds, error handling, and integration scenarios  
- All 102 tests pass including enhanced time decay tests with accurate minute-based decay calculations
- Build successful with TypeScript compilation and updated manual acceptance documentation

### File List
- Modified: src/core/config.ts - Added TIME_DECAY configuration constants
- Modified: src/core/Pet.ts - Enhanced applyTimeDecay() method with configurable intervals and rates
- Modified: src/core/__tests__/Pet.test.ts - Replaced hardcoded tests with comprehensive configurable decay tests
- Validated: src/extension.ts - Existing CLI integration confirmed working correctly

## QA Results
*[To be filled by QA Agent]*