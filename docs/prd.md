# **状态栏宠物 产品需求文档 (PRD)**

### **版本: 0.1**

## **1. 目标与背景 (Goals and Background Context)**

#### **目标 (Goals)**
* **构建 MVP:** 创建一个功能完整的状态栏 ASCII 宠物，包含能量条、基于 Token 消耗的喂养机制、以及由能量驱动的状态表情变化（开心、饥饿、生病、死亡、重生）。
* **验证核心循环:** 验证我们设计的“编码-喂养-反馈”核心游戏循环是否对开发者有足够的吸引力，能够促使他们持续使用。
* **提供情感价值:** 为开发者提供一种非干扰性的、轻松的陪伴，改善其日常编码体验。

#### **背景 (Background Context)**
基于已批准的项目简报，我们确认开发者在长时间的独立工作中存在情感需求缺口。本项目旨在通过一款无缝集成在 Claude Code 状态栏的虚拟宠物，将开发者的编码行为转化为积极的情感反馈，以解决现有工具在此方面的空白。

#### **变更日志 (Change Log)**
| 日期 | 版本 | 描述 | 作者 |
| :--- | :--- | :--- | :--- |
| 2025-08-21 | 0.1 | PRD 初始草案创建 | John (PM) |

## **2. 需求 (Requirements)**

#### **功能性需求 (Functional Requirements)**
* **FR1:** 系统必须在 Claude Code 状态栏中持续显示一个由 ASCII 字符组成的宠物。
* **FR2:** 宠物旁边必须显示一个可视化的能量条，用以表示其当前状态。
* **FR3:** 当用户在编辑器中产生编码活动（消耗Token）时，宠物的能量条必须增加。
* **FR4:** 当用户在设定的一段时间内没有编码活动时，宠物的能量条必须减少。
* **FR5:** 宠物的 ASCII 表情必须根据能量条的数值自动变化，以反映其不同状态（如开心、饥饿、生病、死亡）。
* **FR6:** 用户必须能通过一个特定的命令来“领养”一只新宠物，以重置死亡后的状态。

#### **非功能性需求 (Non-Functional Requirements)**
* **NFR1:** 扩展程序必须是高性能且轻量级的，其对 IDE 的 CPU 和内存占用必须降到最低，不能对用户的编码体验产生可感知的性能影响。
* **NFR2:** 所有的状态更新都必须是环境式(ambient)和非干扰性的，不能使用弹窗或系统通知。
* **NFR3:** 扩展程序的所有数据和逻辑必须完全在用户本地运行和存储，不得向任何外部服务器发送任何与用户代码或使用习惯相关的数据，以保障隐私。
* **NFR4:** 扩展程序必须能在所有支持 Claude Code 的操作系统上（Windows, macOS, Linux）稳定运行。

## **3. 用户界面设计目标 (User Interface Design Goals)**

#### **整体 UX 愿景 (Overall UX Vision)**
界面应当是**环境式 (ambient) 的、令人愉悦的、且几乎无形的**。它应该感觉像是 IDE 原生的一部分，而不是一个外挂。用户只需一瞥，就能理解宠物的状态，无需主动投入注意力。

#### **关键交互范式 (Key Interaction Paradigms)**
* **主要交互 (Passive):** 核心交互是被动的。宠物对用户的编码活动做出反应，用户无需进行任何直接点击或操作。
* **次要交互 (Command-based):** 唯一的主动操作是通过 IDE 的命令面板执行的（例如，“领养新宠物”），MVP 阶段不设任何图形化配置界面。

#### **核心屏幕与视图 (Core Screens and Views)**
**假设:** 本项目没有传统的“屏幕”或“视图”。**唯一的用户界面就是状态栏本身**，以及一个用于“重生”的命令面板条目。

#### **无障碍设计 (Accessibility)**
**建议:** 我们应确保状态栏的文本对屏幕阅读器是友好的（例如，可以读出“宠物状态：开心，能量值85%”）。ASCII 字符本身应选择高对比度的样式。

#### **品牌 (Branding)**
**建议:** 无需任何品牌元素。产品的“品牌”就是宠物本身的个性和趣味性。

#### **目标设备与平台 (Target Device and Platforms)**
跨平台的桌面 IDE 环境（Windows, macOS, Linux）。

## **4. 技术假设 (Technical Assumptions)**

#### **仓库结构 (Repository Structure):**
本项目将采用**单一代码仓库 (Polyrepo)** 的形式。由于这是一个独立的 IDE 扩展，因此无需复杂的 Monorepo 结构。

#### **服务架构 (Service Architecture):**
采用**纯本地化/无服务器 (Serverless)** 架构。所有应用逻辑、计算和数据存储均在用户本地的客户端（IDE扩展环境）中完成，不依赖任何远程后端服务器。

#### **测试要求 (Testing Requirements):**
测试策略应至少覆盖**单元测试和集成测试 (Unit + Integration)**。单元测试用于验证核心逻辑（如能量条算法），集成测试用于验证扩展与模拟的 Claude Code API 之间的交互。

#### **其他技术假设与要求 (Additional Technical Assumptions and Requests):**
* **开发语言:** 必须使用 TypeScript 进行开发，以保证代码质量和类型安全。
* **API 集成:** 扩展的核心功能依赖于对 Claude Code 扩展 API 的调用。开发应参考 `sirmalloc/ccstatusline` 项目 (https://github.com/sirmalloc/ccstatusline) 作为状态栏 API 的主要实现范例。
* **数据隐私:** 必须严格遵守纯本地化原则，任何用户数据（包括Token消耗量）都不能离开用户计算机。

## **5. 史诗列表 (Epic List)**

### **史诗 1: MVP - 核心宠物体验 (Epic 1: MVP - Core Pet Experience)**
**目标:** 建立并发布一个功能完整的状态栏宠物 MVP，包含其核心的能量条生命周期和与用户编码活动的互动机制，以验证产品的核心吸引力。

## **6. 史诗详情 (Epic Details)**

### **史诗 1: MVP - 核心宠物体验 (Epic 1: MVP - Core Pet Experience)**

**史诗目标 (Epic Goal):**
这个史诗将交付一个完整的、端到端的用户体验。它涵盖了从扩展的初始设置、能量条的核心逻辑、所有宠物状态的转换，到最终的重生循环。完成这个史诗后，产品将准备好进行首次用户验证。

---
#### **Story 1.1: 宠物的首次亮相 (Pet's First Appearance)**
**作为一个** 开发者,
**我想要** 在安装扩展后，能在状态栏看到一个基础的宠物图标和能量条,
**以便于** 我能确认扩展已正确安装并开始运行。

**验收标准 (Acceptance Criteria):**
1. 扩展安装并激活后，一个默认的 ASCII 宠物和一个满格的能量条会出现在状态栏。
2. 宠物的初始 ASCII 表情为“开心”。
3. 宠物的显示不会干扰或覆盖状态栏的其他重要信息。

---
#### **Story 1.2: 宠物的“心跳” (Energy Logic Core)**
**作为一个** 系统,
**我需要** 一个核心的能量管理模块,
**以便于** 所有其他功能（如喂养、状态变化）都有一个统一、可靠的数据来源。

**验收标准 (Acceptance Criteria):**
1. 创建一个独立的能量逻辑模块，负责管理一个 0-100 的能量值。
2. 该模块提供增加、减少和获取当前能量值的函数接口。
3. 模块内部定义了各个状态（开心、饥饿、生病、死亡）对应的能量阈值。
4. 模块的所有核心逻辑都必须有单元测试覆盖。

---
#### **Story 1.3: 编码与喂养 (Feeding the Pet)**
**作为一个** 开发者,
**我想要** 我的编码活动能够被识别并增加宠物的能量,
**以便于** 我的工作能立即带来积极的游戏反馈，感到被奖励。

**验收标准 (Acceptance Criteria):**
1. 扩展能够监听编辑器中的编码活动来追踪 Token 的消耗。
2. Token 的消耗会调用能量模块的“增加”函数。
3. 状态栏中的能量条能够实时（或准实时）地更新，以反映能量的增加。

---
#### **Story 1.4: 时间的流逝 (The Passage of Time)**
**作为一只** 宠物,
**我希望** 在长时间未被喂养时我的能量会减少,
**以便于** 提醒我的主人（开发者）关注我的状态。

**验收标准 (Acceptance Criteria):**
1. 系统中有一个定时器（例如，每小时触发一次）。
2. 如果在定时器触发时，近期没有发生过编码活动，定时器会调用能量模块的“减少”函数。
3. 状态栏中的能量条会相应地更新，以反映能量的减少。

---
#### **Story 1.5: 宠物的表情 (Emotional Expressions)**
**作为一个** 开发者,
**我想要** 看到宠物的 ASCII 表情根据其能量值而变化,
**以便于** 我能直观地、一目了然地了解它的状态。

**验收标准 (Acceptance Criteria):**
1. 当能量值高于 80% 时，显示“开心”或“跳舞”的 ASCII 表情。
2. 当能量值低于 40% 时，显示“饥饿”的 ASCII 表情。
3. 当能量值低于 10% 时，显示“生病”的 ASCII 表情。
4. 当能量值为 0 时，显示“死亡”的 ASCII 表情。

---
#### **Story 1.6: 新的开始 (A New Beginning)**
**作为一个** 开发者,
**我希望** 在我的宠物死亡后，有一个简单的方式可以领养一只新的,
**以便于** 我可以重新开始这个养成体验。

**验收标准 (Acceptance Criteria):**
1. 在 IDE 的命令面板中，提供一个命令（例如，“状态栏宠物：领养一只新宠物”）。
2. 只有当宠物当前状态为“死亡”时，该命令才可用。
3. 执行该命令后，宠物的能量和状态会重置为初始的“开心”和满能量状态。

---
#### **Story 1.7: 宠物的记忆 (State Persistence)**
**作为一个** 开发者,
**我希望** 当我关闭并重新打开 IDE 时，我的宠物状态能够被保存和恢复,
**以便于** 获得一个连续、不中断的体验。

**验收标准 (Acceptance Criteria):**
1. 宠物的当前能量值在每次变化后，都会被保存到本地存储中。
2. 当扩展启动时，会从本地存储加载上一次的能量值。
3. 扩展启动时，会计算自上次关闭以来的时间，并相应地应用能量衰减规则。

## **7. 清单检查结果报告 (Checklist Results Report)**

#### **PRD 与史诗验证摘要 (PRD & Epic Validation Summary)**

| 类别 (Category) | 状态 (Status) | 关键问题 (Critical Issues) |
| :--- | :--- | :--- |
| 1. 问题定义与背景 | PASS | 无 |
| 2. MVP 范围定义 | PASS | 无 |
| 3. 用户体验需求 | PASS | 无 |
| 4. 功能性需求 | PASS | 无 |
| 5. 非功能性需求 | PASS | 无 |
| 6. 史诗与故事结构 | PASS | 无 |
| 7. 技术指导 | PASS | 无 |
| 8. 跨功能需求 | PASS | 无 |
| 9. 清晰度与沟通 | PASS | 无 |