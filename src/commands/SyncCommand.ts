import { CCUsageReader } from '../services/CCUsageReader';
import { SupabaseSyncService, SupabaseConfig, PetRecord } from '../services/SupabaseSyncService';
import { PetStorage } from '../services/PetStorage';
import { ConfigService } from '../services/ConfigService';
import { SUPABASE_CONFIG } from '../core/config';
import { AnimalType, ANIMAL_CONFIGS } from '../core/config';
import * as fs from 'fs';
import * as path from 'path';

interface SyncCommandOptions {
  startDate?: string;
  endDate?: string;
  dryRun?: boolean;
  verbose?: boolean;
  supabaseUrl?: string;
  supabaseApiKey?: string;
}

export class SyncCommand {
  name = 'sync';
  description = 'Sync pet data and token usage to Supabase database';

  async execute(args: string[]): Promise<void> {
    const options = this.parseArguments(args);

    if (options.verbose) {
      console.log('üîÑ Starting Supabase sync process...');
    }

    try {
      // È™åËØÅSupabaseÈÖçÁΩÆ
      const supabaseConfig = this.getSupabaseConfig(options);
      if (!supabaseConfig.url || !supabaseConfig.apiKey) {
        console.error('‚ùå Supabase configuration missing');
        console.error('Set SUPABASE_URL and SUPABASE_ANON_KEY environment variables');
        console.error('or use --supabase-url and --supabase-api-key options');
        process.exit(1);
      }

      // Âä†ËΩΩÂÆ†Áâ©Êï∞ÊçÆ
      const petStorage = new PetStorage();
      const currentPetState = petStorage.loadState();
      
      if (!currentPetState) {
        console.error('‚ùå No pet data found. Please create a pet first.');
        process.exit(1);
      }
      
      if (options.verbose) {
        console.log(`üìÇ Loaded pet data: ${currentPetState.petName} (${currentPetState.animalType})`);
      }

      // ÂàùÂßãÂåñSupabaseÂêåÊ≠•ÊúçÂä°ÔºàÈúÄË¶ÅÊèêÂâçÂàùÂßãÂåñÁî®‰∫éÊü•ËØ¢Êï∞ÊçÆÔºâ
      const syncService = new SupabaseSyncService({ config: supabaseConfig });

      // Êô∫ËÉΩÁ°ÆÂÆöÂêåÊ≠•Êó•ÊúüËåÉÂõ¥
      const { startDate, endDate } = await this.determineSyncDateRange(options, currentPetState, syncService);
      
      if (options.verbose) {
        console.log(`üìÖ Sync date range: ${startDate} to ${endDate}`);
      }

      // ËØªÂèñccusageÊï∞ÊçÆ
      const ccusageReader = new CCUsageReader();
      const tokenUsageRecords = await ccusageReader.readTokenUsage(startDate, endDate);
      
      if (options.verbose) {
        console.log(`üìä Found ${tokenUsageRecords.length} token usage records`);
      }

      if (options.dryRun) {
        console.log('üîç DRY RUN MODE - No data will be synced');
        console.log(`Pet: ${currentPetState.petName} (${ANIMAL_CONFIGS[currentPetState.animalType as AnimalType].name})`);
        console.log(`Records to sync: ${tokenUsageRecords.length}`);
        if (tokenUsageRecords.length > 0) {
          console.log('Sample records:');
          tokenUsageRecords.slice(0, 3).forEach(record => {
            console.log(`  ${record.usage_date}: ${record.total_tokens} tokens ($${record.cost_usd})`);
          });
        }
        return;
      }


      // ÂêåÊ≠•ÂÆ†Áâ©ËÆ∞ÂΩï
      if (options.verbose) {
        console.log('üêæ Syncing pet record...');
      }

      const petRecord: PetRecord = {
        id: currentPetState.uuid, // ‰ΩøÁî®Êú¨Âú∞ÂÆ†Áâ©ÁöÑUUID‰Ωú‰∏∫‰∏ªÈîÆ
        pet_name: currentPetState.petName,
        animal_type: currentPetState.animalType,
        emoji: currentPetState.emoji || ANIMAL_CONFIGS[currentPetState.animalType as AnimalType]?.emoji,
        birth_time: currentPetState.birthTime.toISOString(),
        // Â¶ÇÊûúÂÆ†Áâ©Â∑≤Ê≠ª‰∫°ÔºåËÆ°ÁÆóÊ≠ª‰∫°Êó∂Èó¥ÂíåÂ≠òÊ¥ªÂ§©Êï∞
        ...(currentPetState.energy === 0 ? {
          death_time: new Date().toISOString(),
          survival_days: Math.floor((Date.now() - currentPetState.birthTime.getTime()) / (24 * 60 * 60 * 1000))
        } : {})
      };

      const petId = await syncService.syncPetRecord(petRecord);
      if (options.verbose) {
        console.log(`‚úÖ Pet record synced with ID: ${petId}`);
      }

      // Ê£ÄÊü•ÈúÄË¶ÅÂêåÊ≠•ÁöÑËÆ∞ÂΩï
      const recordsToSync = await syncService.getRecordsToSync(petId, tokenUsageRecords);
      
      if (recordsToSync.length === 0) {
        console.log('‚úÖ All records are already synced');
        return;
      }

      if (options.verbose) {
        console.log(`üì§ Syncing ${recordsToSync.length} new token usage records...`);
      }

      // ÂêåÊ≠•token‰ΩøÁî®ËÆ∞ÂΩï
      const syncResult = await syncService.syncTokenUsageRecords(recordsToSync);

      if (syncResult.success) {
        console.log(`‚úÖ Successfully synced ${syncResult.status.processed} records`);
      } else {
        console.error(`‚ùå Sync completed with errors: ${syncResult.message}`);
        if (syncResult.status.errors.length > 0) {
          console.error('Errors:');
          syncResult.status.errors.forEach(error => {
            console.error(`  ${error}`);
          });
        }
        process.exit(1);
      }

    } catch (error) {
      console.error(`‚ùå Sync failed: ${error instanceof Error ? error.message : String(error)}`);
      if (options.verbose && error instanceof Error) {
        console.error('Stack trace:', error.stack);
      }
      process.exit(1);
    }
  }

  private parseArguments(args: string[]): SyncCommandOptions {
    const options: SyncCommandOptions = {};
    
    for (let i = 0; i < args.length; i++) {
      const arg = args[i];
      
      switch (arg) {
        case '--start-date':
          options.startDate = args[++i];
          break;
        case '--end-date':
          options.endDate = args[++i];
          break;
        case '--dry-run':
          options.dryRun = true;
          break;
        case '--verbose':
        case '-v':
          options.verbose = true;
          break;
        case '--supabase-url':
          options.supabaseUrl = args[++i];
          break;
        case '--supabase-api-key':
          options.supabaseApiKey = args[++i];
          break;
        case '--help':
        case '-h':
          this.showHelp();
          process.exit(0);
          break;
        default:
          if (arg.startsWith('--')) {
            console.error(`Unknown option: ${arg}`);
            console.error('Run "ccpet sync --help" for usage information.');
            process.exit(1);
          }
      }
    }

    // È™åËØÅÊó•ÊúüÊ†ºÂºè
    if (options.startDate && !this.isValidDateFormat(options.startDate)) {
      console.error('‚ùå Invalid start date format. Use YYYY-MM-DD format.');
      process.exit(1);
    }

    if (options.endDate && !this.isValidDateFormat(options.endDate)) {
      console.error('‚ùå Invalid end date format. Use YYYY-MM-DD format.');
      process.exit(1);
    }

    return options;
  }

  private getSupabaseConfig(options: SyncCommandOptions): SupabaseConfig {
    // ‰ºòÂÖàÁ∫ßÔºöÂëΩ‰ª§Ë°åÂèÇÊï∞ > ÁéØÂ¢ÉÂèòÈáè > Áî®Êà∑ÈÖçÁΩÆ > ÈªòËÆ§ÈÖçÁΩÆ
    const configService = new ConfigService();
    const userConfig = configService.getConfig();
    
    return {
      url: options.supabaseUrl || 
           process.env.SUPABASE_URL || 
           userConfig.supabase?.url || 
           SUPABASE_CONFIG.DEFAULT_URL,
      apiKey: options.supabaseApiKey || 
              process.env.SUPABASE_ANON_KEY || 
              userConfig.supabase?.apiKey || 
              SUPABASE_CONFIG.DEFAULT_API_KEY
    };
  }

  private isValidDateFormat(dateStr: string): boolean {
    const dateRegex = /^\d{4}-\d{2}-\d{2}$/;
    if (!dateRegex.test(dateStr)) {
      return false;
    }

    try {
      const date = new Date(dateStr + 'T00:00:00.000Z');
      return !isNaN(date.getTime()) && date.toISOString().startsWith(dateStr);
    } catch {
      return false;
    }
  }

  private showHelp(): void {
    console.log('ccpet sync - Sync pet data and token usage to Supabase');
    console.log('');
    console.log('Usage: ccpet sync [options]');
    console.log('');
    console.log('Options:');
    console.log('  --start-date <YYYY-MM-DD>    Start date for token usage sync');
    console.log('  --end-date <YYYY-MM-DD>      End date for token usage sync');
    console.log('  --dry-run                    Preview sync without making changes');
    console.log('  --verbose, -v                Show detailed output');
    console.log('  --supabase-url <url>         Supabase project URL');
    console.log('  --supabase-api-key <key>     Supabase anonymous API key');
    console.log('  --help, -h                   Show this help message');
    console.log('');
    console.log('Configuration Priority (highest to lowest):');
    console.log('  1. Command line options (--supabase-url, --supabase-api-key)');
    console.log('  2. Environment variables (SUPABASE_URL, SUPABASE_ANON_KEY)');
    console.log('  3. User configuration (ccpet config set supabase.url <value>)');
    console.log('  4. Default configuration from .mcp.json');
    console.log('');
    console.log('Configuration Commands:');
    console.log('  ccpet config set supabase.url <url>           # Set Supabase URL');
    console.log('  ccpet config set supabase.apiKey <key>        # Set API key');
    console.log('  ccpet config set supabase.autoSync true       # Enable auto sync');
    console.log('  ccpet config set supabase.syncInterval 720    # Sync every 12 hours');
    console.log('');
    console.log('Examples:');
    console.log('  ccpet sync                           # Sync all available data');
    console.log('  ccpet sync --dry-run                 # Preview sync without changes');
    console.log('  ccpet sync --verbose                 # Show detailed sync progress');
    console.log('  ccpet sync --start-date 2024-01-01   # Sync data from specific date');
    console.log('  ccpet sync --start-date 2024-01-01 --end-date 2024-01-31');
    console.log('');
    console.log('Smart Sync Logic:');
    console.log('  - First sync: From pet birth date to current date');
    console.log('  - Later syncs: From last synced date to current date');
    console.log('');
    console.log('Note: ccusage CLI tool must be installed and available in PATH');
  }

  /**
   * Êô∫ËÉΩÁ°ÆÂÆöÂêåÊ≠•Êó•ÊúüËåÉÂõ¥
   * @param options ÂëΩ‰ª§ÈÄâÈ°π
   * @param petState ÂÆ†Áâ©Áä∂ÊÄÅ
   * @param syncService SupabaseÂêåÊ≠•ÊúçÂä°
   * @returns ÂºÄÂßãÂíåÁªìÊùüÊó•Êúü
   */
  private async determineSyncDateRange(
    options: SyncCommandOptions,
    petState: any,
    syncService: SupabaseSyncService
  ): Promise<{ startDate: string; endDate: string }> {
    const today = new Date().toISOString().split('T')[0]; // YYYY-MM-DD

    // Â¶ÇÊûúÁî®Êà∑ÊòéÁ°ÆÊåáÂÆö‰∫ÜÊó•ÊúüËåÉÂõ¥Ôºå‰ºòÂÖà‰ΩøÁî®Áî®Êà∑ÊåáÂÆöÁöÑ
    if (options.startDate || options.endDate) {
      return {
        startDate: options.startDate || this.getPetBirthDate(petState),
        endDate: options.endDate || today
      };
    }

    try {
      // Ê£ÄÊü•ÊòØÂê¶ÊòØÁ¨¨‰∏ÄÊ¨°ÂêåÊ≠•ÔºàÈÄöËøáÊü•ËØ¢Êï∞ÊçÆÂ∫ì‰∏≠ÊòØÂê¶ÊúâËØ•ÂÆ†Áâ©ÁöÑËÆ∞ÂΩïÔºâ
      const isFirstSync = await this.isFirstSync(petState.uuid, syncService);

      if (isFirstSync) {
        // Á¨¨‰∏ÄÊ¨°ÂêåÊ≠•Ôºö‰ªéÂÆ†Áâ©Âá∫ÁîüÊó•ÊúüÂêåÊ≠•Âà∞ÂΩìÂâçÊó•Êúü
        const petBirthDate = this.getPetBirthDate(petState);
        return {
          startDate: petBirthDate,
          endDate: today
        };
      } else {
        // ÂêéÁª≠ÂêåÊ≠•Ôºö‰ªéÊúÄÂêé‰∏ÄÊù°ËÆ∞ÂΩïÁöÑÊó•ÊúüÁöÑ‰∏ã‰∏ÄÂ§©ÂºÄÂßãÂêåÊ≠•Âà∞ÂΩìÂâçÊó•Êúü
        const lastSyncDate = await this.getLastSyncDate(petState.uuid, syncService);
        const nextDay = this.getNextDay(lastSyncDate);
        
        return {
          startDate: nextDay,
          endDate: today
        };
      }
    } catch (error) {
      // Âá∫ÈîôÊó∂ÂõûÈÄÄÂà∞‰ªéÂÆ†Áâ©Âá∫ÁîüÊó•ÊúüÂºÄÂßãÂêåÊ≠•
      console.warn('‚ö†Ô∏è  Failed to determine smart sync range, falling back to full sync');
      return {
        startDate: this.getPetBirthDate(petState),
        endDate: today
      };
    }
  }

  /**
   * Ëé∑ÂèñÂÆ†Áâ©Âá∫ÁîüÊó•ÊúüÔºàÂü∫‰∫épet-state.jsonÊñá‰ª∂ÁöÑÂàõÂª∫Êó∂Èó¥ÊàñÂÆ†Áâ©ÁöÑbirthTimeÔºâ
   * @param petState ÂÆ†Áâ©Áä∂ÊÄÅ
   * @returns Âá∫ÁîüÊó•Êúü (YYYY-MM-DD)
   */
  private getPetBirthDate(petState: any): string {
    try {
      // ‰ºòÂÖà‰ΩøÁî®ÂÆ†Áâ©ÁöÑbirthTime
      if (petState.birthTime) {
        return new Date(petState.birthTime).toISOString().split('T')[0];
      }

      // ÂõûÈÄÄÂà∞pet-state.jsonÊñá‰ª∂ÁöÑÂàõÂª∫Êó∂Èó¥
      const petStateFilePath = path.join(process.env.HOME || '~', '.claude-pet', 'pet-state.json');
      if (fs.existsSync(petStateFilePath)) {
        const stats = fs.statSync(petStateFilePath);
        return stats.birthtime.toISOString().split('T')[0];
      }
    } catch (error) {
      // Â¶ÇÊûúÈÉΩËé∑Âèñ‰∏çÂà∞Ôºå‰ΩøÁî®‰ªäÂ§©ÁöÑÊó•Êúü
      console.warn('‚ö†Ô∏è  Could not determine pet birth date, using today');
    }
    
    return new Date().toISOString().split('T')[0];
  }

  /**
   * Ê£ÄÊü•ÊòØÂê¶‰∏∫Á¨¨‰∏ÄÊ¨°ÂêåÊ≠•
   * @param petId ÂÆ†Áâ©ID
   * @param syncService ÂêåÊ≠•ÊúçÂä°
   * @returns ÊòØÂê¶‰∏∫Á¨¨‰∏ÄÊ¨°ÂêåÊ≠•
   */
  private async isFirstSync(petId: string, syncService: SupabaseSyncService): Promise<boolean> {
    try {
      const lastSyncDate = await syncService.getLastSyncDate(petId);
      return lastSyncDate === null; // Â¶ÇÊûúÊ≤°ÊúâËÆ∞ÂΩïÔºåÂàôÊòØÁ¨¨‰∏ÄÊ¨°ÂêåÊ≠•
    } catch (error) {
      // Â¶ÇÊûúÊü•ËØ¢Â§±Ë¥•ÔºåÂÅáËÆæÊòØÁ¨¨‰∏ÄÊ¨°ÂêåÊ≠•
      return true;
    }
  }

  /**
   * Ëé∑ÂèñÊúÄÂêé‰∏ÄÊ¨°ÂêåÊ≠•ÁöÑÊó•Êúü
   * @param petId ÂÆ†Áâ©ID
   * @param syncService ÂêåÊ≠•ÊúçÂä°
   * @returns ÊúÄÂêéÂêåÊ≠•ÁöÑÊó•Êúü
   */
  private async getLastSyncDate(petId: string, syncService: SupabaseSyncService): Promise<string> {
    try {
      const lastDate = await syncService.getLastSyncDate(petId);
      if (lastDate) {
        return lastDate;
      }
    } catch (error) {
      console.warn('‚ö†Ô∏è  Failed to get last sync date, using fallback');
    }
    
    // Â¶ÇÊûúËé∑ÂèñÂ§±Ë¥•ÔºåÂõûÈÄÄÂà∞7Â§©Ââç‰Ωú‰∏∫ÂÆâÂÖ®margin
    const fallback = new Date();
    fallback.setDate(fallback.getDate() - 7);
    return fallback.toISOString().split('T')[0];
  }

  /**
   * Ëé∑ÂèñÊåáÂÆöÊó•ÊúüÁöÑ‰∏ã‰∏ÄÂ§©
   * @param dateStr Êó•ÊúüÂ≠óÁ¨¶‰∏≤ (YYYY-MM-DD)
   * @returns ‰∏ã‰∏ÄÂ§©ÁöÑÊó•Êúü (YYYY-MM-DD)
   */
  private getNextDay(dateStr: string): string {
    const date = new Date(dateStr + 'T00:00:00.000Z');
    date.setUTCDate(date.getUTCDate() + 1);
    return date.toISOString().split('T')[0];
  }
}